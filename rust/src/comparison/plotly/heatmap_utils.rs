/// This module provides helpers for the functionality the heatmap module builds on top of the
/// native plotly heatmap features.
/// Namely this is
/// - "uneven boxsizes"

use std::collections::{BTreeMap, HashMap};

use rust_decimal::{dec, prelude::FromPrimitive, Decimal};

use crate::comparison::plotly::heatmap::EntryDatum;

/// Build the bucket edges and layout (bucket -> slot count) from entries produced by `entries_fn`.
///
/// `cmp_data` is a slice of `(label, data)` pairs. The function is generic over the
/// data type `D` so the same logic can be tested with a minimal test struct. `entries_fn`
/// should yield a vector of `EntryDatum` for each `D`.
///
/// Returns:
/// 1. Series intended to be used for the x-axis
/// 2. Vector which maps a bucket (floor(num)) to the amount of elements needed for this bucket
pub(super) fn generate_buckets_from_entries<F, D>(
    cmp_data: &Vec<(String, D)>,
    entries_fn: &F,
) -> (Vec<Decimal>, Vec<(Decimal, usize)>)
where
    F: Fn(&D) -> Vec<EntryDatum>,
{
    // bucket -> season -> values
    let mut bucket_map: BTreeMap<Decimal, HashMap<String, Vec<Decimal>>> = BTreeMap::new();

    // place the nums used by a season in buckets and store to which season it belongs in order to
    // obtain the maximum per season
    for (season, data) in cmp_data {
        let entries = entries_fn(data);
        for e in &entries {
            let b = e.num.floor();
            bucket_map
                .entry(b)
                .or_default()
                .entry(season.clone())
                .or_default()
                .push(e.num);
        }
    }

    // determine max slots per bucket and produce edges
    let mut layouts = Vec::new();
    let mut edges = Vec::new();

    for (bucket, seasons) in &bucket_map {
        let max_slots = seasons.values().map(|v| v.len()).max().unwrap_or(1);

        // width of a sub-slot inside a bucket
        let w = Decimal::ONE / Decimal::from_usize(max_slots).unwrap();
        edges.extend((0..max_slots).map(|i| Decimal::from_usize(i).unwrap() * w + *bucket));

        layouts.push((*bucket, max_slots));
    }

    // add one element more to the x axis so boxes are not centered
    edges.push(edges.last().unwrap() + dec![1]);

    (edges, layouts)
}

/// Build the Z matrix (rows per label) from entries generated by `entries_fn`.
///
/// `cmp_data` is a slice of `(label, data)` pairs where `data` is generic `D`.
/// Returns `(texts_rows, z_rows)` where `texts_rows` is `Vec<Vec<String>>` (hover
/// text per cell) and `z_rows` is `Vec<Vec<Option<f64>>>` (heatmap numeric cells).
pub(super) fn build_z_from_entries<D, F>(
    cmp_data: &[(String, D)],
    layouts: &[(Decimal, usize)],
    entries_fn: &F,
) -> (Vec<Vec<String>>, Vec<Vec<Option<f64>>>)
where
    F: Fn(&D) -> Vec<EntryDatum>,
{
    let total_cols: usize = layouts.iter().map(|(_, slots)| *slots).sum();

    let mut z_rows: Vec<Vec<Option<f64>>> = Vec::with_capacity(cmp_data.len());
    let mut texts_rows: Vec<Vec<String>> = Vec::with_capacity(cmp_data.len());

    for (_, season_data) in cmp_data.iter() {
        // bucket -> ordered values for this season
        let mut season_val_map: HashMap<Decimal, Vec<Option<f64>>> = HashMap::new();
        let mut season_text_map: HashMap<Decimal, Vec<Option<String>>> = HashMap::new();

        for e in &entries_fn(season_data) {
            let b = e.num.floor();
            season_val_map.entry(b).or_default().push(e.val);

            let b = e.num.floor();
            season_text_map.entry(b).or_default().push(e.hover.clone());
        }

        let mut z_row = Vec::with_capacity(total_cols);
        let mut text_row: Vec<String> = Vec::with_capacity(total_cols);
        for (bucket, slots) in layouts {
            match season_val_map.get(bucket) {
                Some(values) if !values.is_empty() => {
                    let last = values.last().cloned().unwrap_or(None);

                    for i in 0..*slots {
                        let cell = values.get(i).cloned().unwrap_or(last);
                        z_row.push(cell);
                    }
                }
                _ => {
                    // bucket does not exist for this season
                    for _ in 0..*slots {
                        z_row.push(None);
                    }
                }
            }

            // Hover texts (parallel logic so indices line up with z_row)
            match season_text_map.get(bucket) {
                Some(texts) if !texts.is_empty() => {
                    let last_text = texts.last().cloned().unwrap_or(None);
                    for i in 0..*slots {
                        let cell_text = texts.get(i).cloned().unwrap_or(last_text.clone());
                        // convert Option<String> -> String for flattened output
                        text_row.push(cell_text.unwrap_or_default());
                    }
                }
                _ => {
                    for _ in 0..*slots {
                        text_row.push(String::new());
                    }
                }
            }
        }
        z_rows.push(z_row);
        texts_rows.push(text_row);
    }
    (texts_rows, z_rows)
}

#[cfg(test)]
mod tests {
    use super::*;
    // define a tiny test data type that holds pre-built EntryDatum
    #[derive(Clone, Debug)]
    struct Dummy {
        entries: Vec<EntryDatum>,
    }

    fn simple_sample_data() -> Vec<(String, Dummy)> {
        // two seasons with different entries
        let d1 = Dummy {
            entries: vec![
                EntryDatum {
                    num: dec![0.2],
                    val: Some(1.0),
                    hover: Some("a".to_string()),
                },
                EntryDatum {
                    num: dec![1],
                    val: Some(2.0),
                    hover: Some("b".to_string()),
                },
            ],
        };
        let d2 = Dummy {
            entries: vec![EntryDatum {
                num: dec![1],
                val: Some(3.0),
                hover: Some("c".to_string()),
            },
            EntryDatum {
                num: dec![1.5],
                val: Some(5.0),
                hover: Some("x".to_string()),
            }],
        };

        vec![
            ("season_one".to_string(), d1.clone()),
            ("season_two".to_string(), d2.clone()),
        ]
    }

    #[test]
    fn generate_buckets_from_entries_simple() {
        let cmp_data = simple_sample_data();

        // entries_fn just clones the entries
        let (edges, layouts) =
            generate_buckets_from_entries(&cmp_data, &|d: &Dummy| d.entries.clone());

        // 2.5 added to make the boxes not centered to their x-value
        assert_eq!(edges, vec![dec![0], dec![1], dec![1.5], dec![2.5]]);
        assert_eq!(layouts, vec![(dec![0], 1), (dec![1], 2)]);
    }

    #[test]
    fn build_z_from_entries_simple() {
        let cmp_data = simple_sample_data();

        // entries_fn just clones the entries
        let (_, layouts) =
            generate_buckets_from_entries(&cmp_data, &|d: &Dummy| d.entries.clone());

        // sanity check
        assert_eq!(layouts.len(), 2);

        // now build z
        let (texts, z) = build_z_from_entries(&cmp_data, &layouts, &|d: &Dummy| d.entries.clone());

        // z rows == number of seasons
        assert_eq!(texts, vec![
            vec!["a".to_string(), "b".to_string(), "b".to_string()],
            vec!["".to_string(),  "c".to_string(), "x".to_string()],
        ]);
        assert_eq!(z, vec![
            vec![Some(1.0), Some(2.0), Some(2.0)],
            vec![None,      Some(3.0), Some(5.0)],
        ]);
    }
}
